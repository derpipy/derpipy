#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from __future__ import annotations

from datetime import datetime
from typing import Union, List, Dict, Type

from luckydonaldUtils.logger import logging
from luckydonaldUtils.typing import JSONType

__author__ = 'luckydonald'
__all__ = ['DerpiModel', {% for class in classes %}{{ class.name.__repr__() }}{% if not loop.last %}, {% endif -%}{% endfor %}]

logger = logging.getLogger(__name__)
if __name__ == '__main__':
    logging.add_colored_handler(level=logging.DEBUG)
# end if


{# #{% set class = Class(
    name='Awards',
    params=[
        Parameter(
            name='image_url',
            type='String',
            description='The URL of this award.',
            optional=False
        ),
        Parameter(
            name='title',
            type='String',
            description='The title of this award.',
            optional=False
        ),
        Parameter(
            name='id',
            type='Integer',
            description='The ID of the badge this award is derived from.',
            optional=False
        ),
        Parameter(
            name='label',
            type='String',
            description='The label of this award.',
            optional=False
        ),
        Parameter(
            name='awarded_on',
            type='RFC3339 datetime',
            description='The time, in UTC, when this award was given.',
            optional=False
        )
    ]
) %}{# #}


class DerpiModel(object):
    """ Base class for all models """
    pass
# end class DerpiModel


{% for class in classes %}

class {{ class.name }}(DerpiModel):
    """
    A parsed {{ class.name }} response of the Derpibooru API.
    Yes, a better description should be here.

    {% for param in class.params %}
    :param {{ param.name }}: {{ param.description }}
    :type  {{ param.name }}: {{ param.python_typing_representation(classes) }}{% if param.optional %}|None{% endif %}
    {% endfor %}
    """

    {% for param in class.params %}
    """ {{ param.description }} """
    {{ param.name }}: {% if param.optional %}Union[{% endif %}{{ param.python_typing_representation(classes) }}{% if param.optional %}, None]{% endif %}
    {% endfor %}

    def __init__(
        self, {#
        #}{% for param in class.params %}
        {{ param.name }}: {% if param.optional %}Union[{% endif %}{{ param.python_typing_representation(classes) }}{% if param.optional %}, None] = None{% endif %},
    {%- endfor %}
    ):
        """
        A parsed {{ class.name }} response of the Derpibooru API.
        Yes, a better description should be here.

        {% for param in class.params %}
        :param {{ param.name }}: {{ param.description }}
        :type  {{ param.name }}: {{ param.python_typing_representation(classes) }}{% if param.optional %}|None{% endif %}
        {% endfor %}
        """
        pass
    # end def __init__

    @classmethod
    def validate_dict(cls: Type[{{ class.name }}], data: Union[Dict[str, JSONType]]) -> Dict[str, JSONType]:
        return data
    # end def validate_dict

    @classmethod
    def from_dict(cls: Type[{{ class.name }}], data: Union[Dict, None]) -> Union[{{ class.name }}, None]:
        """
        Deserialize a new {{ class.name }} from a given dictionary.

        :return: new {{ class.name }} instance.
        :rtype: {{ class.name }}|None
        """
        if not data:  # None or {}
            return None
        # end if

        data: Dict = cls.validate_dict(data)
        instance: {{ class.name }} = cls(**data)
        instance._raw = data
        return instance
    # end def from_dict
# end class

{% endfor %}
